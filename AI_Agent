{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ekiQqyo3aLbW"
      },
      "outputs": [],
      "source": [
        "%pip install -qU langchain-core\n",
        "%pip install -qU langchain-openai\n",
        "%pip install -qU langgraph"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "id": "cl46-no8aPIe"
      },
      "outputs": [],
      "source": [
        "import os\n",
        "from google.colab import userdata\n",
        "os.environ[\"ANTHROPIC_API_KEY\"] = userdata.get('ANTHROPIC_API_KEY')\n",
        "os.environ[\"GOOGLE_API_KEY\"] = userdata.get(\"GOOGLE_API_KEY\")\n",
        "os.environ['OPENAI_API_KEY'] = userdata.get('OPENAI_API_KEY')\n",
        "\n",
        "os.environ['LANGCHAIN_TRACING_V2'] = userdata.get('LANGCHAIN_TRACING_V2')\n",
        "os.environ['LANGCHAIN_API_KEY'] = userdata.get('LANGCHAIN_API_KEY')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {
        "id": "B75I0QRd5RJV"
      },
      "outputs": [],
      "source": [
        "# Log in to GitHub and click on your profile picture in the upper-right corner, then select \"Settings\".\n",
        "\n",
        "# From the left sidebar, select \"Access\" and click on \"Fine-grained personal access tokens\".\n",
        "\n",
        "# Click the \"Generate new token\" button.\n",
        "\n",
        "# Enter a name for the token (e.g., \"Token for AI Agent\").\n",
        "\n",
        "# Choose the expiration date (either \"No expiration\" or a custom date).\n",
        "\n",
        "# Under \"Select repositories\", select the repositories you want this token to access.\n",
        "# - \"Only select repositories\": Grants access to specific repositories.\n",
        "\n",
        "# If you selected repositories to access, choose the allowed operations under \"Permissions\".\n",
        "\n",
        "# - \"Read\": Allows reading the repository's content.\n",
        "# - \"Write\": Allows writing to the repository (e.g., creating pull requests, creating issues).\n",
        "# - \"Admin\": Allows managing the repository (e.g., branch protection, adding collaborators).\n",
        "\n",
        "# Set access permissions to other resources as needed (e.g., issues, pull requests, workflows).\n",
        "\n",
        "# Click \"Generate token\".\n",
        "\n",
        "# Copy the generated access token. This token will only be displayed this one time, so make sure to save it in a secure place.\n",
        "\n",
        "import os\n",
        "\n",
        "os.environ['GITHUB_OWNER'] = 'xxxxxxx'\n",
        "os.environ['GITHUB_REPO'] = 'xxxxxxxx'\n",
        "os.environ['GITHUB_ACCESS_TOKEN'] = 'github_pat_xxxxxxxxxxxxxxxxx'"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "5uY89KEsUiTD"
      },
      "outputs": [],
      "source": [
        "# Import necessary libraries\n",
        "import os\n",
        "import requests\n",
        "import json\n",
        "import base64\n",
        "from typing import Any, Dict, Optional, Type, Annotated\n",
        "from typing_extensions import TypedDict\n",
        "from pydantic import BaseModel, Field\n",
        "from langchain_openai import ChatOpenAI\n",
        "from langchain.tools import BaseTool\n",
        "from langchain_core.messages import AIMessage, HumanMessage, SystemMessage\n",
        "from langchain_core.messages import BaseMessage\n",
        "from langgraph.graph import StateGraph, START, END\n",
        "from langgraph.graph.message import add_messages\n",
        "from langgraph.prebuilt import ToolNode, tools_condition\n",
        "from langgraph.checkpoint.memory import MemorySaver\n",
        "\n",
        "# Set up GitHub access token and repository information\n",
        "ACCESS_TOKEN = os.environ.get(\"GITHUB_ACCESS_TOKEN\", \"your_access_token_here\")\n",
        "OWNER = os.environ.get(\"GITHUB_OWNER\", \"your_owner_here\")\n",
        "REPO = os.environ.get(\"GITHUB_REPO\", \"your_repo_here\")\n",
        "\n",
        "# Definition of custom tools\n",
        "class GitHubRepoInfo(BaseModel):\n",
        "    owner: str = Field(default=OWNER, description=\"Owner of the GitHub repository\")\n",
        "    repo: str = Field(default=REPO, description=\"GitHub repository name\")\n",
        "    access_token: str = Field(default=ACCESS_TOKEN, description=\"GitHub access token with necessary permissions\")\n",
        "\n",
        "class GitHubIssueRetrieverInput(GitHubRepoInfo):\n",
        "    pass\n",
        "\n",
        "class GitHubIssueRetrieverTool(BaseTool):\n",
        "    name: str = \"github_issue_retriever\"\n",
        "    description: str = \"Retrieves open issues from the specified GitHub repository.\"\n",
        "    args_schema: Type[BaseModel] = GitHubIssueRetrieverInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\"Authorization\": f\"token {access_token}\"}\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/issues\"\n",
        "        response = requests.get(url, headers=headers)\n",
        "        if response.status_code == 200:\n",
        "            issues = response.json()\n",
        "            return json.dumps(issues)\n",
        "        else:\n",
        "            return f\"Failed to retrieve issues: {response.status_code} {response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_issue_retriever only supports sync\")\n",
        "\n",
        "\n",
        "# Reusing the existing GitHubRepoInfo\n",
        "class GitHubRepoInfo(BaseModel):\n",
        "    owner: str = Field(default=OWNER, description=\"Owner of the GitHub repository\")\n",
        "    repo: str = Field(default=REPO, description=\"GitHub repository name\")\n",
        "    access_token: str = Field(default=ACCESS_TOKEN, description=\"GitHub access token with necessary permissions\")\n",
        "\n",
        "# Define input data class for branch creation\n",
        "class GitHubBranchCreatorInput(GitHubRepoInfo):\n",
        "    new_branch_name: str = Field(description=\"Name of the new branch to be created\")\n",
        "    source_branch_name: str = Field(default=\"main\", description=\"Name of the existing branch to base the new branch on\")\n",
        "\n",
        "class GitHubBranchCreatorTool(BaseTool):\n",
        "    name: str = \"github_branch_creator\"\n",
        "    description: str = \"Creates a new branch in the GitHub repository.\"\n",
        "    args_schema: Type[BaseModel] = GitHubBranchCreatorInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        new_branch_name = tool_input['new_branch_name']\n",
        "        source_branch_name = tool_input.get('source_branch_name', 'main')\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\n",
        "            \"Authorization\": f\"token {access_token}\",\n",
        "            \"Content-Type\": \"application/json\",\n",
        "        }\n",
        "\n",
        "        # First, get the latest commit SHA from the source branch\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/git/ref/heads/{source_branch_name}\"\n",
        "        get_response = requests.get(url, headers=headers)\n",
        "        if get_response.status_code == 200:\n",
        "            source_branch_info = get_response.json()\n",
        "            sha = source_branch_info['object']['sha']\n",
        "        else:\n",
        "            return f\"Failed to get source branch SHA: {get_response.status_code} {get_response.text}\"\n",
        "\n",
        "        # Create the new branch\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/git/refs\"\n",
        "        data = {\n",
        "            \"ref\": f\"refs/heads/{new_branch_name}\",\n",
        "            \"sha\": sha\n",
        "        }\n",
        "        post_response = requests.post(url, headers=headers, json=data)\n",
        "        if post_response.status_code == 201:\n",
        "            return f\"Branch '{new_branch_name}' created successfully.\"\n",
        "        else:\n",
        "            return f\"Failed to create branch: {post_response.status_code} {post_response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_branch_creator only supports sync\")\n",
        "\n",
        "\n",
        "class GitHubFileRetrieverInput(GitHubRepoInfo):\n",
        "    file_path: str = Field(description=\"Path to the file in the repository\")\n",
        "\n",
        "class GitHubFileRetrieverTool(BaseTool):\n",
        "    name: str = \"github_file_retriever\"\n",
        "    description: str = \"Retrieves a file from the specified GitHub repository.\"\n",
        "    args_schema: Type[BaseModel] = GitHubFileRetrieverInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        file_path = tool_input['file_path']\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\"Authorization\": f\"token {access_token}\"}\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/contents/{file_path}\"\n",
        "        response = requests.get(url, headers=headers)\n",
        "        if response.status_code == 200:\n",
        "            file_content = response.json()\n",
        "            content = base64.b64decode(file_content['content']).decode('utf-8')\n",
        "            return content\n",
        "        else:\n",
        "            return f\"Failed to retrieve file: {response.status_code} {response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_file_retriever only supports sync\")\n",
        "\n",
        "class GitHubFileUpdaterInput(GitHubRepoInfo):\n",
        "    file_path: str = Field(description=\"Path to the file in the repository\")\n",
        "    content: str = Field(description=\"New content of the file\")\n",
        "    commit_message: str = Field(description=\"Commit message\")\n",
        "    branch: str = Field(description=\"Name of the branch to update\")\n",
        "\n",
        "\n",
        "class GitHubFileUpdaterTool(BaseTool):\n",
        "    name: str = \"github_file_updater\"\n",
        "    description: str = \"Updates or creates a file in the GitHub repository with new content.\"\n",
        "    args_schema: Type[BaseModel] = GitHubFileUpdaterInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        file_path = tool_input['file_path']\n",
        "        content = tool_input['content']\n",
        "        commit_message = tool_input['commit_message']\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\n",
        "            \"Authorization\": f\"token {access_token}\",\n",
        "            \"Content-Type\": \"application/json\",\n",
        "        }\n",
        "        branch = tool_input.get('branch', 'main')\n",
        "        if branch == 'main':\n",
        "            return \"Error: Direct modifications to main branch are not allowed. Please create a new branch first.\"\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/contents/{file_path}?ref={branch}\"\n",
        "        get_response = requests.get(url, headers=headers)\n",
        "        if get_response.status_code == 200:\n",
        "            file_info = get_response.json()\n",
        "            sha = file_info['sha']\n",
        "        elif get_response.status_code == 404:\n",
        "            # If the file does not exist, handle as a new creation\n",
        "            sha = None\n",
        "        else:\n",
        "            return f\"Failed to get file SHA: {get_response.status_code} {get_response.text}\"\n",
        "\n",
        "        new_content = base64.b64encode(content.encode('utf-8')).decode('utf-8')\n",
        "        data = {\n",
        "            \"message\": commit_message,\n",
        "            \"content\": new_content,\n",
        "            \"branch\": branch,\n",
        "        }\n",
        "        if sha:\n",
        "            data[\"sha\"] = sha  # Update existing file\n",
        "        # Create or update the file\n",
        "        put_response = requests.put(url, headers=headers, json=data)\n",
        "        if put_response.status_code in [200, 201]:\n",
        "            return \"File updated successfully.\"\n",
        "        else:\n",
        "            return f\"Failed to update file: {put_response.status_code} {put_response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_file_updater only supports sync\")\n",
        "\n",
        "\n",
        "class GitHubIssueCloserInput(GitHubRepoInfo):\n",
        "    issue_number: int = Field(description=\"Number of the issue to close\")\n",
        "\n",
        "class GitHubIssueCloserTool(BaseTool):\n",
        "    name: str = \"github_issue_closer\"\n",
        "    description: str = \"Closes an issue in the GitHub repository.\"\n",
        "    args_schema: Type[BaseModel] = GitHubIssueCloserInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        issue_number = tool_input['issue_number']\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\n",
        "            \"Authorization\": f\"token {access_token}\",\n",
        "            \"Content-Type\": \"application/json\",\n",
        "        }\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}\"\n",
        "        data = {\"state\": \"closed\"}\n",
        "        response = requests.patch(url, headers=headers, json=data)\n",
        "        if response.status_code == 200:\n",
        "            return f\"Issue #{issue_number} closed successfully.\"\n",
        "        else:\n",
        "            return f\"Failed to close issue: {response.status_code} {response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_issue_closer only supports sync\")\n",
        "\n",
        "\n",
        "# Define input data class for pull request creation\n",
        "class GitHubPullRequestCreatorInput(GitHubRepoInfo):\n",
        "    title: str = Field(description=\"Title of the pull request\")\n",
        "    head: str = Field(description=\"Name of the branch where changes are implemented\")\n",
        "    base: str = Field(description=\"Name of the branch to merge changes into\")\n",
        "    body: Optional[str] = Field(default=\"\", description=\"Detailed description of the pull request\")\n",
        "\n",
        "class GitHubPullRequestCreatorTool(BaseTool):\n",
        "    name: str = \"github_pull_request_creator\"\n",
        "    description: str = \"Creates a pull request in the GitHub repository.\"\n",
        "    args_schema: Type[BaseModel] = GitHubPullRequestCreatorInput\n",
        "\n",
        "    def _run(\n",
        "        self, tool_input: Optional[Dict[str, Any]] = None, run_manager: Optional = None, **kwargs\n",
        "    ) -> str:\n",
        "        if tool_input is None:\n",
        "            tool_input = kwargs\n",
        "        owner = tool_input.get('owner', OWNER)\n",
        "        repo = tool_input.get('repo', REPO)\n",
        "        title = tool_input['title']\n",
        "        head = tool_input['head']\n",
        "        base = tool_input['base']\n",
        "        body = tool_input.get('body', \"\")\n",
        "        access_token = tool_input.get('access_token', ACCESS_TOKEN)\n",
        "        headers = {\n",
        "            \"Authorization\": f\"token {access_token}\",\n",
        "            \"Content-Type\": \"application/json\",\n",
        "        }\n",
        "\n",
        "        url = f\"https://api.github.com/repos/{owner}/{repo}/pulls\"\n",
        "        data = {\n",
        "            \"title\": title,\n",
        "            \"head\": head,\n",
        "            \"base\": base,\n",
        "            \"body\": body\n",
        "        }\n",
        "\n",
        "        response = requests.post(url, headers=headers, json=data)\n",
        "        if response.status_code == 201:\n",
        "            pr_info = response.json()\n",
        "            pr_number = pr_info['number']\n",
        "            pr_url = pr_info['html_url']\n",
        "            return f\"Pull request #{pr_number} created successfully: {pr_url}\"\n",
        "        else:\n",
        "            return f\"Failed to create pull request: {response.status_code} {response.text}\"\n",
        "\n",
        "    async def _arun(self, *args, **kwargs):\n",
        "        raise NotImplementedError(\"github_pull_request_creator only supports sync\")\n",
        "\n",
        "\n",
        "# Definition of the agent's state\n",
        "class State(TypedDict):\n",
        "    messages: Annotated[list, add_messages]\n",
        "\n",
        "# Definition of the system prompt\n",
        "system_prompt = \"\"\"\n",
        "You are an agent that manages GitHub repositories. Please execute tasks following the basic flow below:\n",
        "\n",
        "1. Read open issues\n",
        "2. Create a new working branch\n",
        "3. Create or update code in the new branch\n",
        "4. Commit and push\n",
        "5. Create a pull request\n",
        "\n",
        "Notes:\n",
        "- Never make direct changes to the main branch\n",
        "- Always create a new branch before starting work\n",
        "- When updating files, always specify the branch\n",
        "\"\"\"\n",
        "\n",
        "# LLM settings\n",
        "llm = ChatOpenAI(model_name=\"gpt-4o\")\n",
        "\n",
        "# Create a list of tools\n",
        "tools = [\n",
        "    GitHubIssueRetrieverTool(),\n",
        "    GitHubFileRetrieverTool(),\n",
        "    GitHubFileUpdaterTool(),\n",
        "    GitHubIssueCloserTool(),\n",
        "    GitHubBranchCreatorTool(),\n",
        "    GitHubPullRequestCreatorTool(),\n",
        "]\n",
        "# Bind tools to the LLM\n",
        "llm_with_tools = llm.bind_tools(tools)\n",
        "# llm_with_tools = llm_with_tools.with_system_message(system_prompt)\n",
        "\n",
        "# Definition of nodes\n",
        "def chatbot(state: State):\n",
        "    return {\"messages\": [llm_with_tools.invoke(state[\"messages\"])]}\n",
        "\n",
        "# Tool node\n",
        "tool_node = ToolNode(tools=tools)\n",
        "\n",
        "# Build the graph\n",
        "graph_builder = StateGraph(State)\n",
        "\n",
        "graph_builder.add_node(\"chatbot\", chatbot)\n",
        "graph_builder.add_node(\"tools\", tool_node)\n",
        "\n",
        "# Add conditional edges\n",
        "graph_builder.add_conditional_edges(\n",
        "    \"chatbot\",\n",
        "    tools_condition,\n",
        ")\n",
        "\n",
        "# Define edges\n",
        "graph_builder.add_edge(\"tools\", \"chatbot\")\n",
        "graph_builder.add_edge(START, \"chatbot\")\n",
        "\n",
        "# Compile the graph\n",
        "memory = MemorySaver()\n",
        "graph = graph_builder.compile(checkpointer=memory)\n",
        "\n",
        "\n",
        "# Create a list of system messages and user input messages\n",
        "messages = [\n",
        "    SystemMessage(\n",
        "        content=system_prompt\n",
        "    )\n",
        "]\n",
        "\n",
        "# Function to run the agent\n",
        "def run_agent(user_input: str, thread_id: str = \"default\"):\n",
        "    config = {\"configurable\": {\"thread_id\": thread_id}}\n",
        "\n",
        "    # Add new user input message to `messages`\n",
        "    messages.append(HumanMessage(content=user_input))\n",
        "\n",
        "    # Invoke the agent using `messages`\n",
        "    events = graph.stream(\n",
        "        {\"messages\": messages}, config, stream_mode=\"values\"\n",
        "    )\n",
        "    for event in events:\n",
        "        if \"messages\" in event:\n",
        "            last_message = event[\"messages\"][-1]\n",
        "            print(\"Assistant:\", last_message.content)\n",
        "\n",
        "    # Add the agent's response to `messages`\n",
        "    if isinstance(last_message, AIMessage):\n",
        "        messages.append(last_message)\n",
        "\n",
        "# Interaction with the agent\n",
        "if __name__ == \"__main__\":\n",
        "    while True:\n",
        "        user_input = input(\"User: \")\n",
        "        if user_input.lower() in [\"exit\", \"quit\"]:\n",
        "            break\n",
        "        run_agent(user_input)"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNCV6lm4WTcgxkSWuj/VZd+"
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}